var documenterSearchIndex = {"docs":
[{"location":"dev_notes/##-Developer-Notes","page":"# Developer Notes","title":"# Developer Notes","text":"","category":"section"},{"location":"dev_notes/###-Function-Signatures","page":"# Developer Notes","title":"## Function Signatures","text":"","category":"section"},{"location":"dev_notes/","page":"# Developer Notes","title":"# Developer Notes","text":"For utility functions with few arguments, we try to keep to the Julia convention of appending an exclamation mark, if a method modifies some  of its arguments, and place those arguments first.","category":"page"},{"location":"dev_notes/","page":"# Developer Notes","title":"# Developer Notes","text":"However, some more complicated functions essential to the algorithm,  like do_iteration, do_restoration, compute_normal_step and compute_descent_step,  can require a multitude of arguments and keeping the correct order during development proves difficult. That is why in this case we use the standard signature","category":"page"},{"location":"dev_notes/","page":"# Developer Notes","title":"# Developer Notes","text":"function algo_function(\n    # iteration information\n    it_index, Δ, it_stat,\n    # objects to evaluate objectives, models and constraints\n    mop, mod, scaler, lin_cons, scaled_cons,\n    # caches for necessary arrays\n    vals, vals_tmp, step_vals, mod_vals, \n    # other important building blocks\n    filter,     # the filter used to drive feasibility\n    step_cache, # an object defining step calculation and holding caches\n    algo_opts;  # general algorithmic settings\n    # then follow custom keyword arguments …\n    custom_kwarg1, kwargs...\n)\n    # Function Body\nend","category":"page"},{"location":"dev_notes/","page":"# Developer Notes","title":"# Developer Notes","text":"We do not use keyword arguments to enable dispatch on custom configuration or cache types, e.g., in the case of compute_descent_step. What arguments are modified, or even guaranteed or required to be modified, should be made clear from docstrings or comments. The compiler does only specialize on function arguments if they are used within in  the function body, but not if they are merely passed through to other functions.","category":"page"},{"location":"dev_notes/###-Medium-Priority-ToDo's","page":"# Developer Notes","title":"## Medium-Priority ToDo's","text":"","category":"section"},{"location":"dev_notes/","page":"# Developer Notes","title":"# Developer Notes","text":"Introduce AbstractSurrogateModelConfig to initialize AbstractSurrogateModel based on custom configuration objects instead of their types.\nMake dim_in or num_vars part of the AbstractMOP and AbstractMOPSurrogate interface.\nAdd dimension information to AbstractNonlinearOperator and AbstractSurrogateModel.   When this is done, some method signatures concerning initialization and updates can be   simplified. (CTRL-F for “dimin”, “numvars”, “numout”, “dimout” etc.)\nIn the modelling and DAG framework, switch names and meaning of dependent variables and   states. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Compromise","category":"page"},{"location":"#Compromise","page":"Home","title":"Compromise","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Compromise.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Compromise]","category":"page"},{"location":"#Compromise.compute_descent_step-Union{Tuple{SC}, Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, SC, Any}} where SC<:Compromise.AbstractStepCache","page":"Home","title":"Compromise.compute_descent_step","text":"compute_descent_step(\n    it_index, Δ, it_stat, mop, mod, scaler, lin_cons, scaled_cons,\n    vals, vals_tmp, step_vals, mod_vals, filter, step_cache, algo_opts\n) :: Real\n\nReturn a criticalty value χ.\nModify step_vals.d to hold the scaled descent step at step_vals.xn.\nModify step_vals.xs to hold vals.x + step_vals.n + step_vals.d,  or equivalently, step_vals.xn + step_vals.d.\nModify step_vals.fxs to hold the surrogate objective values at step_vals.xs.\nThe descent step is computed according to step_cache and this cache can also be  modified.\nUsually, the descent step is computed using the surrogate values stored in mod_vals.   These should not be modified!\n\n\n\n\n\n","category":"method"},{"location":"#Compromise.compute_normal_step-Union{Tuple{SC}, Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, SC, Any}} where SC<:Compromise.AbstractStepCache","page":"Home","title":"Compromise.compute_normal_step","text":"compute_normal_step(\n    it_index, Δ, it_stat, mop, mod, scaler, lin_cons, scaled_cons,\n    vals, vals_tmp, step_vals, mod_vals, filter, step_cache, algo_opts\n)\n\nModify step_vals.n to hold the normal step at vals.x.\nModify step_vals.xn to hold vals.x + step_vals.n.\nThe normal step is computed according to step_cache and this cache can also be  modified.\nUsually, the normal step is computed using the surrogate values stored in mod_vals.   These should not be modified!\n\n\n\n\n\n","category":"method"},{"location":"#Compromise.diff_mod!-Tuple{Any, Any, Any}","page":"Home","title":"Compromise.diff_mod!","text":"Evaluate the model gradients of mod at x and store results in mod_vals::SurrogateValueArrays.\n\n\n\n\n\n","category":"method"},{"location":"#Compromise.eval_and_diff_mod!-Tuple{Any, Any, Any}","page":"Home","title":"Compromise.eval_and_diff_mod!","text":"Evaluate and differentiate mod at x and store results in mod_vals::SurrogateValueArrays.\n\n\n\n\n\n","category":"method"},{"location":"#Compromise.eval_mod!-Tuple{Any, Any, Any}","page":"Home","title":"Compromise.eval_mod!","text":"Evaluate the models mod at x and store results in mod_vals::SurrogateValueArrays.\n\n\n\n\n\n","category":"method"},{"location":"#Compromise.scale!-Tuple{Any, Compromise.AbstractAffineScaler, Any}","page":"Home","title":"Compromise.scale!","text":"Scale ξ and set x according to x = T*ξ + t.\n\n\n\n\n\n","category":"method"},{"location":"#Compromise.scale_eq!-Tuple{Any, Compromise.AbstractAffineScaler, Any}","page":"Home","title":"Compromise.scale_eq!","text":"Make Aξ + b ? 0 applicable in scaled domain via A(inv(T)*x - inv(T)*t) + b ? 0.\n\n\n\n\n\n","category":"method"},{"location":"#Compromise.set_linear_constraints!-Tuple{Any, Any, Any, Any, Any, Symbol}","page":"Home","title":"Compromise.set_linear_constraints!","text":"Add the constraint c + A * x .?= b to opt and return a JuMP expression for A*x.\n\n\n\n\n\n","category":"method"},{"location":"#Compromise.unscale!-Tuple{Any, Compromise.AbstractAffineScaler, Any}","page":"Home","title":"Compromise.unscale!","text":"Unscale x and set ξ according to ξ = inv(T)*x - inv(T)*t.\n\n\n\n\n\n","category":"method"}]
}
